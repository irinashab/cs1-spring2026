<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CS1 – Lesson 9: Functions</title>
  <link rel="stylesheet" href="assets/style.css">
</head>
<body>
<header>
    <h1>Lesson 9: Functions</h1>
        
    </header>
 <main>
<div class="callout">
    <p><strong>What is a function?</strong> A function is a <em>relation</em> between input(s) and output — think of it as a “recipe” or a “machine” that produces outputs from inputs.</p>
  </div>

  <h2>Where we are so far</h2>
  <p>We started by writing programs as a sequence of instructions:</p>
  <ul>
    <li>“Naked numbers” (literals)</li>
    <li>Variables (with types: <code>int</code>, <code>float</code>, …)</li>
    <li>Processing mechanisms you already know (<code>setup()</code>, <code>draw()</code>, event handlers)</li>
    <li>Conditionals that let our code branch</li>
  </ul>

  <h3>Why this approach breaks down</h3>
  <ul>
    <li>It works for small-scale problems.</li>
    <li>It gets messy as programs grow.</li>
    <li>It becomes hard to track details and ensure the right information reaches the right part of the code.</li>
  </ul>

  <hr />

  <h2>Good programming: two big ideas</h2>
  <p>More code is not necessarily better. A good programmer is measured by the amount of <em>functionality</em> they can produce cleanly.</p>

  <h3>1) Modularity</h3>
  <ul>
    <li>Break down code into smaller named pieces.</li>
    <li>More manageable, readable programs.</li>
    <li>Fewer local variables per “module” → less to keep in your head at once.</li>
  </ul>

  <h3>2) Reusability</h3>
  <ul>
    <li>Copy/paste duplication is a maintenance problem.</li>
    <li>If you need the same behavior in many places, put it in a function and call it.</li>
  </ul>

  <hr />

  <h2>What counts as a function in Processing?</h2>
  <p>A function is a <strong>named block of code</strong>. In different languages you’ll hear: functions, procedures, subroutines, methods.</p>
  <p>Examples you already know:</p>
  <ul>
    <li><code>setup()</code>, <code>draw()</code>, <code>mousePressed()</code></li>
    <li><code>background()</code>, <code>ellipse()</code>, <code>rect()</code>, <code>random()</code></li>
  </ul>

  <hr />

  <h2>The function signature</h2>
  <p>The “signature” includes:</p>
  <ul>
    <li><strong>Return type</strong> (e.g., <code>void</code>, <code>int</code>, <code>float</code>)</li>
    <li><strong>Name</strong> (e.g., <code>drawEye</code>)</li>
    <li><strong>Formal parameters</strong> (types + variable names inside parentheses)</li>
  </ul>

  <pre><code>// General form:
returnType functionName(type1 param1, type2 param2, ...) {
  // body
}</code></pre>

  <h3>Example: drawing an eye (avoid copy/paste)</h3>
  <p>If you can draw one eye with a chunk of code, you don’t want to copy that chunk every time you need another eye. Put the drawing logic in a function and call it with different parameters.</p>

  <pre><code>// Declaration (definition)
void drawEye(float x, float y, float s) {
  // s = size (scale)
  ellipse(x, y, s, s);                 // white eyeball
  ellipse(x + 0.15*s, y, 0.35*s, 0.35*s); // pupil (example)
}

// Use (call) the function from draw()
void draw() {
  background(255);
  drawEye(120, 140, 80);
  drawEye(220, 140, 50);
}</code></pre>

  <div class="callout small">
    <p><strong>Key idea:</strong> declaring a function is not enough — you must <em>call</em> it for it to run.</p>
  </div>

  <hr />

  <h2>Parameters vs arguments (terminology)</h2>
  <ul>
    <li><strong>Formal parameters</strong>: the variables in the function definition.</li>
    <li><strong>Actual parameters</strong> (often called “arguments”): the values you pass at the call site.</li>
  </ul>

  <pre><code>// Formal parameters: (float x, float y, float s)
void drawEye(float x, float y, float s) { ... }

// Actual parameters: (120, 140, 80)
drawEye(120, 140, 80);</code></pre>

  <h3>Rules for passing parameters</h3>
  <ul>
    <li>You must pass the same <strong>number</strong> of actual parameters as the function expects.</li>
    <li>Each actual parameter must match the expected <strong>type</strong> (int into int, float into float, etc.).</li>
    <li>You can pass:
      <ul>
        <li>Literal values (<code>20</code>, <code>4.3</code>)</li>
        <li>Variables (<code>x</code>, <code>y</code>, <code>size</code>)</li>
        <li>Expressions (<code>8 + 3</code>, <code>random(0,10)</code>)</li>
      </ul>
    </li>
    <li>Parameters act like <strong>local variables</strong> inside the function (they live only inside that function body).</li>
  </ul>

  <hr />

  <h2>What am I really passing?</h2>
  <p>In Processing/Java:</p>
  <ul>
    <li><strong>Primitive types</strong> (<code>int</code>, <code>float</code>, <code>double</code>, <code>char</code>, …) are passed by copying the value.</li>
    <li>So changing the parameter inside the function does <strong>not</strong> change the original variable you passed in.</li>
  </ul>

  <pre><code>void changeIt(int n) {
  n = 999; // changes only the local copy
}

void draw() {
  int a = 5;
  changeIt(a);
  println(a); // still 5
}</code></pre>

  <hr />

  <h2>Return type</h2>
  <p>The return type is the data type a function sends back to the caller.</p>
  <ul>
    <li><code>void</code> means “returns nothing.”</li>
    <li>If the return type is <code>int</code>, the function must end by returning an integer value.</li>
  </ul>

  <pre><code>// returns a bigger number
int bigger(int a, int b) {
  if (a &gt; b) return a;
  else return b;
}

void draw() {
  int m = bigger(7, 12);
  println(m); // 12
}</code></pre>

  <hr />

  <h2>Mini-checklist (what I want you to internalize)</h2>
  <ul>
    <li>Use functions to <strong>decompose</strong> a problem (break it into parts).</li>
    <li>Use functions to <strong>abstract</strong> details (hide messy code behind a name).</li>
    <li>Parameters are how you feed information into a function.</li>
    <li>Return values are how a function gives information back.</li>
    <li>Don’t copy/paste: extract the repeated pattern into a function.</li>
  </ul>
</main>
<div id="footer-placeholder"></div>

<script>
  fetch("assets/includes/footer.html")
    .then(response => response.text())
    .then(html => {
      document.getElementById("footer-placeholder").innerHTML = html;
    })
    .catch(err => console.error("Footer load failed:", err));
</script>


    </body>
</html>